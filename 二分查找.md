视频网址：https://www.bilibili.com/video/BV1AP41137w7/?spm_id_from=333.880.my_history.page.click&vd_source=581928e4b99382eb56fc764576a884b1

这个视频讲解了二分查找的循环退出的条件以及查找区间的开闭问题。比如以下例子：
```
int nums[6]={5,7,7,8,8,10};
int n=nums.size();
int L=0,R=n-1,target=8;
while(L<=R)
{
  int m=L+(R-L)/2;
  if(nums[m]>=target)
    R=m-1;
  else
    L=m+1;
}
return L;
```
这个例子采用[L,R]闭区间的方法进行二分查找，为什么每次令L=m+1，R=m-1呢，关键就在于视频中所讲的**循环不变量**，即：**L-1及其左边的数一定是红色的，R+1及其右边的数一定是蓝色的**，每一次通过比较m与目标值后都能确定[L,m]或[m,R]的颜色。
![image](https://github.com/litterqi/experience-and-records-of-coding/assets/123362884/c5b30069-58a7-4e70-a2aa-847beaaa2b60)

那为什么循环退出条件是L<=R呢，是因为当L=R时，闭区间[L,R]中有一个数，就是L(R)，它的颜色还未确定，因此还需要进行一次判断，到了下一步L=m+1或R=m-1时，区间[L,R]中不再有数，二分查找结束。

可能我们会产生疑问，既然最后L已经等于R了，此时直接返回L不就可以了吗，为什么还要再做一次判断呢。原因有两个，第一个就是上面讲的保持循环不变量的正确性和红蓝染色的完整性；第二个原因是如果直接返回L，L并不一定是正确的答案，在本例中，
如果此时的`nums[m]>=target`，那么直接返回L没有问题，但如果`nums[m]<target`，那L就应该是正确答案的前一个数，必须要经过判断后，L=m+1(即L+=1)再返回L，才是正确答案。

另外，在其它题目中可能采用开区间(L,R)，左闭右开区间[L,R)或左开右闭区间(L,R]进行二分查找，对应的循环退出的条件以及L,R的赋值问题需要根据循环不变量进行相应的改变。
