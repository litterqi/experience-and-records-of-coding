题目网址：https://leetcode.cn/problems/house-robber-ii/?envType=daily-question&envId=2023-09-17

这题与前一题(打家劫舍 I)同样属于动态规划问题，区别在于上一题是线性队列，而这一题是环形队列。对于环形队列我们之前遇到过一题(Monkey Party)，我们于是想到和那一题一样使用破环为链的方法，即在数组末尾将原数组复制一遍，然而，这道题实际上并不需要这样做。下面从两个方面阐释这题：

`dp[i]=max(dp[i−2]+nums[i],dp[i−1])`

1.关于这个状态转移方程，最直观的解释就是：定义dp[i]为考虑前i个房子所能偷到的最大价值，那么对于第i个房子，有偷与不偷两种状态。如果选择偷，那么价值就是dp[i-2]+nums[i]；如果选择不偷，那么价值就是dp[i-1]，最终dp[i]就等于max(dp[i-2]+nums[i],dp[i-1])。

但是我们可能会对这个式子产生一些怀疑，比如，如果dp[i-1]并没有取第i-1个房子，那么第i个房子就可以偷，那么此时的dp[i]不应该是dp[i-1]+nums[i]吗？

对，确实是这样，但是，我们注意到既然第i-1个房子没有取，那么此时dp[i-1]就等于dp[i-2]，所以dp[i]=dp[i-2]+nums[i]依然是正确答案。

2.关于题解中处理环的方法，对于第一个房子有偷与不偷两种状态，因而将两种情况对应的区间[0,n-2]，[1,n-1]的答案计算出，并取这两者中的最大值作为最终答案。

我们会感到疑惑，为什么只考虑这两种情况就可以，而不需要将其分为n个长度为n-1的线性队列来求解呢？

实际上，将环分为n个线性队列，就是指定了考虑偷窃的房屋的起点和终点，然而，这n种情况要么就是选择了偷第一个房子，要么就是选择不偷，总可以归纳进这两种情况里，所以并不需要分为n种情况考虑。
